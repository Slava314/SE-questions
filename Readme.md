# 8. Стратегии конструирования ПО. Экстремальное программирование

Экстремальное программирование (extreme programming, XP) ориентировано на группы до 10 человек.

Вся группа обязательно находится в одном помещении.

Процесс:

- гибкий
- динамичный
- итеративный
- может быть изменяющимся - XP наиболее для этого подходит

Основные "занятия":

- написание кода
- тестирование
- получение требований/изменений от заказчика
- проектирование

Приспособление к изменениям (динамика) из-за:

- постоянной связи с заказчиком
- выбора простейшего решения
- быстрой обратной связи
- профилактики проблем

Основные практики XP:

- игра в планирование
  - от заказчика получаем объём работ, временные требования и сроки выпуска
  - от разработчиков - временные оценки, последствия и ход работы
- небольшие версии
  - выпуск маленьких и простых версий
  - версия обязательно должна быть завершённой
  - примерно 1 версия в 14 дней
- метафора
  - видение проекта с примерными требованиями архитектуры
  - сведения об архитектуре
- простой дизайн
  - проходят все тесты
  - отсутствует дублирующая логика
  - минимальное число классов/методов
  - новое добавляется только тогда, когда оно нужно
- тестирование
  - юнит-тесты для всего кода от разработчиков
  - функциональное тестирование от заказчика
  - код разрабатывается вместе с тестами или после них
- рефакторинг
  - изменение программы без фактического изменения функциональности
  - для упрощения добавления нового функционала
- парное программирование (!!!)
  - разработчики работают парами
  - тот, кто пишет код, думает над конкретной реализацией
  - тот, кто рядом, думает стратегически
  - состав пар меняется
- коллективное владение
  - код - общий, мгновенно изменяется при необходимости
- непрерывная интеграция
  - интеграция кода - постоянная, не реже одного раза в день
  - кончается после прохождения всех тестов
  - ответственные - те, кто внесли изменения
- 40ч рабочая неделя
  - переработки нежелательны, свидетельствуют о неправильной организации работы
  - отпуск обязателен
- локальный заказчик (!!!)
  - вместе с разработчиками обязательно присутствует представитель заказчика - тот, кто будет пользоваться продуктом
  - отвечает на возникающие у разработчиков вопросы
  - наличие представителя - способ наискорейшей коммуникации

# 9. Стратегии конструирования ПО. Методология SCRUM

SCRUM изначально появился в компании Toyota. Подход оказался хорошо масштабируемым и переносимым на разработку ПО.

SCRUM:

- гибкий
- итерационный
- адаптируемый под многие процессы
- масштабируемый, что важно для гибких подходов
- применим к любым этапам/особенностям разработки ПО
- хорошо стыкуется с использованием ООП-подхода

Планирование реализуется с помощью спринтов:

- каждые 7/14/30 дней, не больше 30 дней
- реализует часть функциональности

Встречи разработчиков:

- до начала каждого спринта - sprint planning meeting
- ежедневно - тот самый scrum ("схватка с англ.")
- после конца спринта - спринт-ревью с демонстрацией результатов

Генерируемые артефакты:

- backlog 
  - список целей/задач, необходимых для реализации всего проекта
  - "журнал пожеланий проекта"
- sprint backlog
  - список целей/задач, необходимых для реализации спринта
  - "журнал пожеланий спринта"
- burndown chart (диаграмма сгорания задач)
  - показывает идеальный темп выполнения задач, текущее положение дел и "температуру" проекта
- scrum board
  - минимальный размер - 3 столбца: TODO, in progress и done
  - строки - либо зоны ответственности разработчиков, либо типы задач

Роли участников:

- основные
  - product owner
  - scrum master
  - scrum team
- остальные
  - пользователи
  - эксперты-консультанты

Ход работы (относительно выполнения задач):

- формируется product backlog (все изменения - только сюда)
- его небольшой кусочек выносится в sprint backlog (заморожен ДО КОНЦА СПРИНТА)
- команда независимо работает над своим спринтом
- на выходе - готовый кусок функционала

Ход работы (относительно зон ответственности):

- заказчик определяет функциональные требования, периодически их меняет
- владелец продукта расставляет приоритеты
- формируются группы (обычно 1-6, реже вплоть до 9) для выполнения отдельных частей проекта
- формируется project backlog
- формируется sprint backlog для каждой группы
- выполняются спринты (автономно)

На каждой scrum-встрече каждый из команды:

- рассказывает, что сделал за предыдущий день
- рассказывает, что сделает за сегодняшний
- рассказывает, что мешало работе (scrum master пытается разрешить эти проблемы)

SCRUM эффективен без каких-либо менеджеров из-за:

- ежедневных встреч для "синхронизации" работы
- небольших групп

SCRUM часто объединяется с прочими методологиями, сейчас почти отсутствует в чистом виде.

# 10. Стратегии конструирования ПО. Бережливая разработка ПО 

Разработана в компании Toyota. 
Является адаптивной эволюционной статегией с  рекомендуемой командой до 10 человек. Отличается низкой продолжительностю проекта, наличию промежуточных версий и пригодностью к работе с информационными системами.

Когда команда следует принципам бережливой разработки, она не просто выполняет задачи, а стремится сделать продукт с наименьшим количеством ошибок

## Идея:

Бережливость заключается в сокращении потерь. 
В компании вносят только те изменения, которые приносят пользу, требуют минимум затрат и отнимают не более 30% запланированного времени.

## Потери: 

- Потери при разработке ПО 
  - Лишние функциональные возможности. Делаем вещи, которые не нужны. 
- Избыточное проектирование (Overengineering)
  - Тратим много веремни на "полировку", что не требуется для конечного продукта и только тратит время
- Незавершенные работы   
  - Незавершенные работы из-за изменений требований в процессе работы
- Поиск и исправление ошибок 
  - Время на поиск и исправление ошибок
- Ожидание 
  - Разные ожидания, когда мы ждем других разработчиков, результатов тестов и т.д.
- Избыточные процессы 
- Дефекты

![Диаграмма бережливой разработки](img/lean_1.png)

## Принципы:

- Исключение или уменьшение потерь 
  - Исключение того, что не приносит пользы.
- Постоянное обучение 
  - Активная обратная связь с заказчиком, чтобы своевременно появлялась информация об изменениях. Чтобы разработчики не тратили время на то, что системе не нужно или на то, что изменилось. 
- Позднее принятие решений 
  - Не прогнозы, а факты. Хотим сделать как можно проще не на основе прогноза о том, что будут сложные труктуры, а на фактической реализации, т.е. когда в действительности становится фактом то, что нужно делать архитектуру сложнее. 
- Быстрая доставка 
  - Короткие итерации с передачей версий заказчику. 
- Мотивация команды 
  - Люди – не ресурс. ОТношение к людям как к единомышленникам. МНогие вопросы решаются совместно, распределение задач. Иными словами - максимальная вовлеченность команды в принятие решений. 
- Интегрирование 
  - Целостная архитектура. Понимание архитектуры заказчиком. Общее виденье о том, что происходит с системой и ее организациейю
- Целостное видение 
  - Разделение разработчиками принципов бережливости.
  - Видение проекта как единое целое. 

В последнее время бережливая разработка очень популярна во многих отраслях.

# 11. Управление требованиями. Требования в программных проектах. Свойства требований

Разработка требований - самая сложная часть проектирования ПО.

Проблемы определения требований:

* Требования пользователей постоянно меняются;
* Требования (заказчика) бывают неясны, двусмысленны, противоречивы и неполны;
* Пользователи могут быть недостаточно представительны *(видим только один взгляд на систему от одной группы пользователей)*;
* Получаемые спецификации недостаточно детализированы для правильного проведения проектирования.

Требование - *(стандарт: IEEE 1990)*:

- Условие или возможность, необходимые пользователю для решения его задач или достижения цели;
- Условие или возможность, которым должна отвечать или которыми должна обладать система или ее компоненты, чтобы удовлетворить контракт, стандарт, спецификацию или иной формальный документ;
- Документированное представление условия или возможности, указанное в (1) и (2).

При сборе требований хочется определить некоторые свойства, позволяющие определить **качество** собранных требований. *They are as follows*:

- Корректность;
- Однозначность;
- Полнота;
- Непротиворечивость;
- Приоритезация;
- Проверяемость;
- Модифицируемость;
- Отслеживаемость.

### Подробнее о свойствах и зачем они вообще:

**Корректность** - требование корректно, если оно отражает пожелания заказчика.
**Однозначность** - возникает, если при решении можно воспользоваться разными способами решения задачи *(50 shades of grey for grey button)*. Требования однозначны, если их формулировка подразумевает только одну трактовку.
**Полнота** - требования полны, если **все** пожелания заказчика нашли отражения в списке требований.
**Непротиворечивость** - возникает из-за объема спецификации или в разных "специфициремых" областях продукта *(неявные противоречия)*, обычно выявляется только путем глубокого анализа требований. Требования непротиворечивы, если нет нескольких требований, которые явно или неявно противоречат друг другу.
**Приоритезация** - требования должны быть разделены на относительные классы приоритетов, показывающие **значимость по времени или важности реализации** в системе.
**Проверяемость** - требования проверяемы, если они сформулированы таким образом, что каждое можно проверить и убедиться, выполнено оно или нет. Проверяемые требования обычно выражены **количественно**, непроверяемые - **качественно** *("быстрая работа" - качественное требование, плохое, в общем)*.
**Модифицируемость** - требования модифицируемы, если они сформулирвоаны таким образом, что предполагают относительно простую их модификацию *(как свойство оно плохо формализуемо, но в целом нужно и важно)*.
**Отслеживаемость** - требования отслеживаемы, если по каждому требованию можно проследить:

* Реализовано ли оно?
* Где конкретно оно реализовано?
* Оттестировано ли оно?

# 12. Управление требованиями. Типы требований. Проблемы определения требований

Виды требований достаточно условно делят на две группы:

* **Функциональные** (функции, которые должна выполнять система) (***ЧТО нужно сделать***). Формулируются как:
  * Бизнес-требования;
  * Ползовательские требования;
  * Собственно функциональные требования;
* **Нефункциональные** требования (***КАК нужно сделать***):
  * Ограничения;
  * Требования к качеству;

Для различных систем одни и те же требования могут принадлежать к разным группам (real-time системы, где скорость работы - **функциональное** требование. Либо еще какой-нибудь пример с эргономикой для случаев, когда удобство пользователя стоит на первом месте). В целом именно поэтому деление условно. 

### Функциональные требования

* Определяют набор функций, которые необходимо реализовать;
* Отвечают на вопрос ***ЧТО надо сделать?***.

По способу формулировки делятся на:

* Бизнес-требования:
  * Формулируются заказчиками;
  * Описывают цели, которых требуется достичь с данной системой;
  * Обычно - укрупненные, не содержат деталей;
  * (Глобально) определяют назначение ПО;
  * *Иногда описываются в документе о видении и границах проекта*.
* Пользовательские требования:
  * Какие задачи можно решить с помощью системы;
  * Формулируются со стороны пользователя.
* Функциональные требования:
  * Определяют требуемую функциональность.

Собранные бизнес-требования и пользовательские требования обычно анализируются и на их основе создают функциональные требования, которые, в свою очередь, документируют с помощью спецификации требований:

![](img/requirements.png)

### Нефункциональные требования

* Отвечают на вопрос ***КАК надо сделать?***.
* Характеристики качества включают требования к:
  * надежности,
  * совместимости,
  * эффективности,
  * гибкости,
  * эргономике,
  * безопасности.
* Ограничения:
  * на программные интерфейсы, в т. ч. к внешним системам,
  * требования к применяемому оборудованию и ПО *(совместимость с win10, например)*,
  * соответствие стандартам и правилам,
  * требования к архитектурным решениям *(- Почему это может быть требованием? - Например, если разрабатываем часть чужой системы со своей архитектурой, и пытаемся в нее вписаться)*,
  * бюджет,
  * сроки.

### Общие ограничения на требования

Правило "2 из 3":

![](img/restrictions.png)

Что **НЕ** является требованиями?

* Детали архитектуры;
* Детали реализации;
* Сведения о планировании;
* Сведения о тестировании *(- Почему? - Пусть заказчик идет лесом, мы можем удовлетворить **уровень протестированности** (покрытие тестов, но это уже не о тестах, а о **требованиях к качеству**), а не написать ему N модульных тестов. Ицыксон сам толком не объяснил, почему, просто требование очевидно ненужное)*;
* Проектная информация *(оставьте менеджеру его работу!)*:
  * Процесс разработки;
  * Команда разработки;

# 13. Разработка требований. Выявление и анализ требований

Разработка требований - также отдельный этап инженерии требований. Ее разделяют на два этапа, результатом которых является **спецификация требований**.

![](img/13requirements.png)

### Выявление требований

Хотим узнать максимальное количество информации о разрабатываемой системе.

Используем все доступные средства, чтобы получить максимально возможный (пусть избыточный) объем требований заказчика.

Заинтересованные лица, участвующие в процессе:

* Заказчики;
* Менеджеры;
* Пользователи:
  * операторы,
  * администраторы,
  * ...
* Разработчики;
* Служба поддержки;
* Другие.

**Заказчик != пользователь**
Очень часто у заказчика и пользователя разные требования, заказчик может навредить пользователю при формировании требований.

*Классический подход (использовался ранее в классических методологиях разработки) подразумевал, что разработка требований и формирование спецификации требований - задача заказчика. Заказчик предоставляет исполнителю готовые требования.*

*Время показало, что подход нерабочий (заказчики не в состоянии сформировать спецификацию требований). Теперь **задача разработки требований - в первую очередь задача исполнителя**. Заказчик - главный источник информации, но окончательная спецификация требований остается за исполнителем. И этот этап - серьезная работа, котрую нужно оплачивать, выделять сроки, планировать...*

Способы выявления требований:

* Семинары;
* Интервью;
* Создание прототипов;
* Исследование;
* Работа с фокус-группами;
* *Остальные подобные перечисленным способы*.

**Семинар** - (самое популярное) открытое совместное обсуждение стоящих задач:

* Заказчик:
  * излагает имеющиеся требования,
  * отвечает на вопросы исполнителя;
* Исполнитель:
  * слушают требования заказчика,
  * задают уточняющие вопросы,
  * документируют требования.
    В результате формируются документы, после анализа превращающиеся в спецификацию требований.

**Интервью** - (если заказчик имеет смутное представление о разрабатываемом продукте, позволяет понизить требования к его IT-квалификации) целенаправленный опрос-интервью:

* Исполнитель:
  * готовит специализированный вопросник (анкету),
  * задает вопросы в соответствии с анкетой,
  * докоментирует ответы заказчика,
  * поясняет заказчику детали, если необходимо;
* Заказчик:
  * отвечает на вопросы исполнителя.

**Создание прототипов** - лучше один раз показать, чем много раз переспрашивать. Процесс:

* Обсуждение стоящих высокоуровневых задач;
* Исполнитель:
  * создает прототип,
  * демонстрирует,
  * исправляет недостатки,
  * документирует финальный прототип;
* Заказчик:
  * смотрит прототип и вносит изменения.

Прототипирование применяется, если:

* Имеются не все требования;
* Нужно быстро увидеть некоторые свойства продукта:
  * Удобство;
  * Внешний вид;
  * Применимость;
* Проектируются:
  * Информационные системы;
  * Программные продукты с ГПИ (GUI);

Для создания прототипа исползьуются:

* Средства быстрой разработки приложений;
* Специальные средства макетирования.

Общее устройство прототипирования:

![](img/13prototypes.png)

Достоинства:

* Обеспечивает определение полных требований к ПО;
* Наглядно для заказчика;
* Позволяет на ранних этапах уидеть основные параметры проекта.

Недостатки:

* По сути не отражает полный жизненный цикл;
* Заказчик может принять макет за продукт (важно этот момент довести до заказчика, лучше заранее);
* Разработчик может принять макет за продукт (ожидаемые проблемы: немасштабируемость, ненадежность, незащищенность, проблемы с обработкой ошибок...).

**Исследование** - исследуем рынок и потребности пользователя. Общий алгоритм:

* Исполнитель:
  * получает от заказчика общее представление о продукте *("- Хочу калькулятор, который завоюет рынок")*;
  * исследует рынок и выявляет востребованные характеристики продукта;
  * Анализирует решения конкурентов;
  * Документирует актуальные свойства проектируемого продукта;
* Заказчик:
  * Предоставление общего видения продукта;
  * Корректировка и утверждение предложения исполнителя.

**Работа с фокус-группами** - составляем фокус-группу из будущих пользователей и ориентируемся на них (что из самых важных функций должно быть и т.п.). Обсудив продукт с фокус-группой, формируем ТЗ и обсуждаем его с заказчиком.

# Вопрос 14. Разработка требований. Анализ требований 

Разработка требований состоит из двух этапов: выявление (сбор) требований и анализ требований. 

- выявляем требования 
- анализируем 
- формируем cпецификацию

**Выявление требований** - (расходящийся) процесс, цель которого собрать как можно больше данных о системе которую хотим разработать 

- Заинтересованные лица:
  + Заказчики (заказчик и пользователь - разные лица)
  + Менеджеры
  + Пользователи (операторы, администраторы, ...)
  + Разработчики
  + Служба поддержки
  + Другие лица
  + Анализ требований - (сходящийся) процесс, уже есть требования. Мы хотим: 
- уточняет данные 
- устанавливает приоритеты 
- структурирует информацию 

Результат всего этапа разработки требований - это спецификация требований 

***Уточнение:*** Каждое требование должно быть максимально полным.  

- Уточнение достигается путем повторных встреч с заинтересованными лицами. 
- Не должно появляться много новых требований - иначе следует вернуться к выявлению. 
- На этапы уточнения требования должны быть описаны количественно,  а не качественно, как было на этапе выявления. 

### Приоритезация 

Необходимо отсортировать требования по важности и срочности. 

**!!! Все требования не могут быть основными. Заказчики должны это понять.** 

Приоритеты могут изменяться по мере развития проекта. 

- Каждое требование относится к какой-либо качественной категории по важности: 
- Высокая, средняя, низкая 
- Обязан, должен бы, мог бы 
- Основной, полезный, желаемый 
- Каждое требование относится к какой-либо качественной категории по срочности: 
- Прямо сейчас, чуть позже, когда-нибудь 
- Срочно, чуть позже, потом 
- Сортируются по двум измерениям, составляем матрицу приоритезации: 

### Все ли требования собраны? 

Очень сложно определить все ли требований собраны. Зачастую это зависит от опыта разработчика. Иногда список может получится очень большой и важно остановится в нужный момент и расставить приоритеты. 

# Вопрос 15. Документирование и организация требований. Российские шаблон спецификаций требований. 

Группирование требований, собранных на предыд. этапах 
- требования объединяются в родственные группы (иерархическая структуризация требований)
- Подчинение 
- Уточнение 

В идеале в итоге мы представляем все собранные требования в виде дерева требований 

Способы документирования требований: 

- Документы на естественном языке (английский и на котором говоришь) - 	Графические модели 
- Диаграммы 
- Графы 
- Схемы 
- Потоки 
- Формальные спецификации. Излагаются на математическом языке, на котором требования не могут трактоваться двояко (язык темпоральной логики/ контрактное программирование). Документы на естественном языке полностью неформальны. 

Документы этапа разработки требований: 

- Спецификация требований - что требуется сделать 
- Критерии принятия работ - как будем проверять и сделано ли правильно Одно с другим связано и может быть одним документом. 


### Спецификация требований. 

Надо написать спецификацию. С чего начать? Есть стандарты, шаблоны. 

Фундамент всего последующего планирования, проектирования, реализации проекта. Основание для тестирования проекта 

Основание для документирования проекта 

Должна содержать ограничения проекта НО: не должна содержать деталей проектирования, реализации, тестирования и управления проектом. 

Шаблоны спецификаций требований к ПО. 

Есть большое количество от советских до американских. 

- Существуют различные государственные, отраслевые и корпоративные стандарты - Наиболее распространены в России: 
- ГОСТ 19.201-78. Единая Система Программной Документации. Тех задание. Треб к содержанию и оформлению. Очень старый, но не такой плохой. 
- ГОСТ 34.602-89 “Техническое задание на создание автоматизированной системы” 

**чем отличается ПО от авт. системы?**  Последнее - программно-аппаратный комплекс. Поэтому 34 гост - частичное отношение к разработке ПО 

#### **IEEE 830-1998 “Recommended practice for software requirements specification (SRS)”** 

Разрабатываются много других стандартов, которые могут применяться наравне с европейскими. 
- Следует при необходимости модифицировать шаблон в соответствии с природой и потребностями заказчика 
- Если заказчик не настаивает, гости и шаблон не должен быть догмой. То есть не надо следовать дословно. 
Исключение: корпоративный или военный заказчик. 
Полезный документ: IEEE Guide for Developing system requirements specifications 

#### **ГОСТ 19.201-78. ЕСПД. Техническое задание.** 

Доисторический гост. Выделенное знаком * - непосредственно относится к разработке ПО

- Основания для разработки 
- Назначение разработки 
- Требования к программе или программному изделию - касается нашего раздела (*)
- Требования к программной документации 
- Технико-экономические показатели 
- Стадии и этапы разработки 
- Порядок контроля и приемки - касается нашего раздела (*)
- Приложения 

Требования к программе или программному изделию: 
- Требования к функциональным характеристикам (функциональные требования) 
- Требования к надежности (не функциональные требования) 
- Условия эксплуатации (широко трактуются в этом госте: не только прогр. изделия но и самого оборудования) 
- Требования к составу и параметрам технических средств (не функциональные требования) 
- Требования к информационной и программной совместимости (не функциональные требования) 
- Требования к маркировке и упаковке (перфокарты в те времена) (сейчас зачастую просто не указывается) - Требования к транспортировке и хранению (сейчас зачастую просто не указывается) 
- Специальные требования 

#### **ГОСТ 34.602-89 “Техническое задание на создание автоматизированной системы”**  

- Общие сведения 
- Назначение и цели создания (развития) системы 
- Хар-ка объектов автоматизации 
- Требования к системе 
- Состав и содерж работ по созд системы 
- порядок контроля и приемки системы 
- требования к составу и содержанию работ по подготовке объекта автоматизации к вводу системы в действие (инсталляции) 
- требования к документированию (этап инженерии требований) 
- источники разработки 

Требования к системе: 
- Требования к системе в целом 
- Требования к функциям (задачам), выполняемым системой 
- Требования к видам обеспечения 

Требования к системе в целом: 
- Требования к структуре и функционированию системы 
- Требования к надежности 
- Требования к безопасности 
- Требования к эргономике и технической эстетике (не функциональное) 
- Требования к эксплуатации и техническому обслуживанию 
- Требования к защите информации от несанкционированного доступа 
- Требования по стандартизации и унификации Список не полный, только то что нам нужно 

Требования к функциям (задачам), выполняемым системой: 
- перечень подсистем, их назначение и основные хар-ки 
- Требования к способам связи для информационного обмена между компонентами системы 
- Требования к характеристикам взаимосвязей создаваемой системы со смежными системами 
- Требования к режимам функционирования системы 
- Требования по диагностированию системы 

# 16. Документирование и организация требований. Стандарт IEEE-830

IEEE 830-1998. Данная методика описывает рекомендуемые принципы составления спецификации требований к программному обеспечению.
Заменен ISO/IEC/IEEE 29148:2011.

Описаны содержание и качества хорошей спецификации требований к программному обеспечению (SRS, СТПО) и представлено несколько примеров схем SRS. Эта рекомендуемая практика направлена на определение требований к разрабатываемому программному обеспечению, но также может быть применена для оказания помощи в выборе собственных и коммерческих программных продуктов.

Согласно стандарту техническое задание должно включать следующие разделы:

1. Введение
   - Назначение
   - Область действия;
   - Определения, акронимы и сокращения;
   - Публикации;
   - Краткий обзор
2. Общее описание
   - Перспектива изделия
   - Функции изделия
   - Характеристики пользователей
   - Ограничения
   - Допущения и зависимости
   - Разделение требований
3. Специфические требования
   - Внешние интерфейсы
   - Функции системы
   - Требования к рабочим характеристикам
   - .Логические требования к базе данных
   - Проектные ограничения
   - Атрибуты системы программного обеспечения (нефункциональные требования)

Для раздела "Специфические требования" существует несколько шаблонов, например:

### Шаблон 1. По режимам v1:

1. Требования к внешним интерфейсам

   - Интерфейсы пользователя

   - Аппаратные интерфейсы

   - Интерфейсы программного обеспечения

   - Интерфейсы связи

2. Функциональные требования

   - Режим 1
     - Функциональное требование 1.1
     - ...
     - Функциональное требование 1.n
     - ...
   - Режим 2
     - …
     - Режим m
     - …

3. Требования к рабочим характеристикам

4. Проектные ограничения

5. Атрибуты системы программного обеспечения

6. Другие требования

### Шаблон 2. По режимам v2:

1. Функциональные требования
   - Режим 1
     - Внешние интерфейсы
       - Интерфейсы пользователя
       - Аппаратные интерфейсы
       - Интерфейсы программного обеспечения
       - Интерфейсы связи
     - Функциональные требования
       - Функц. требование 1
       - …
       - Функциональное требование 
   - Режим 2
     - …
   - Режим m
2. Проектные ограничения
3. Атрибуты системы программного обеспечения
4. Другие требования

### Шаблон 3, по классам пользователей:

1. Внешние интерфейсы
   - Интерфейсы пользователя
   - Аппаратные интерфейсы
   - Интерфейсы программного обеспечения
   - Интерфейсы связи
2. Функциональные требования
   - Класс пользователей 1
     - Функциональное требование 1.1
     - …
     - Функц. требование 1.n
     - …
   - Класс пользователей 2
     - …
   - Класс пользователей m
     - Функц. требование m.1
     - …
     - Функц. требование m.n
     - …
3. Требования к рабочим характеристикам
4. Проектные ограничения
5. Атрибуты системы программного обеспечения
6. Другие требования

И другие.

# 17. Документирование требований. Критерии принятия работ. Программа и методика испытаний.

## Критерии принятия работ:

1. Должны быть приняты всеми заинтересованными лицами;
2. Должны быть четкими и недвусмысленными;
3. Разделы методики принятия работы должны определяться количественными параметрами, а не качественными;

## Программа и методика испытаний:

Программа и методика испытаний (ПМИ) — это технический документ, который формализует этап тестирования продукции и составляется на автоматизированную программу (АСУ) или систему. Документ предназначается для выявления параметров, которые обеспечивают определение причин сбоя, показателей качества системы, ее соответствие различным требованиям, проверку и получение проектных решений, а также характеризуют продолжительность и период испытаний.

Документ "Программа и методика испытаний" должен содержать следующие разделы:

1. Объект испытаний;
2. Цель испытаний;
3. Требования к программе;
4. Требования к программной документации;
5. Средства и порядок испытаний;
6. Методы испытаний.

В зависимости от особенностей документа допускается вводить дополнительные разделы.

- В разделе "Объект испытаний" указывают наименование, область применения и обозначение испытуемой программы.
- В разделе "Цель испытаний" должна быть указана цель проведения испытаний.
- В разделе "Требования к программе" должны быть указаны требования, подлежащие проверке во время испытаний и заданные в техническом задании на программу.
- В разделе "Требования к программной документации" должны быть указаны состав программной документации, предъявляемой на испытания, а также специальные требования, если они заданы в техническом задании на программу.
- В разделе "Средства и порядок испытаний" должны быть указаны технические и программные средства, используемые во время испытаний, а также порядок проведения испытаний.
- В разделе "Методы испытаний" должны быть приведены описания используемых методов испытаний. Методы испытаний рекомендуется по отдельным показателям располагать в последовательности, в которой эти показатели расположены в разделах "Требования к программе" и "Требования к программной документации".
- В методах испытаний должны быть приведены описания проверок с указанием результатов проведения испытаний (перечней тестовых примеров, контрольных распечаток тестовых примеров и т.п.).

Протокол испытаний является документом, который содержит результаты исследований (испытаний) и измерений, на основании которых принимается решение о соответствии продукции требованиям технических регламентов, документам по стандартизации или условиям договоров.

# 18. Изменения требований.

### Цели: 

- Управление изменениями требований 
  - Предложение изменений
  - Анализ изменений 
  - Принятие решений 
  - Обновление требований 
  - Обновление планов
- Контроль версий требований 
  - Определение схемы идентификации версий 
  - Определение версий спецификаций требований 
  - Определение версий отдельных требований
- Контроль состояния требования 
  - Определение состояния требований 
  - Регистрация состояния требования
- Прослеживаемость требований 
  - Определение связей с другими требованиями 
  - Определение связей с другими элементам системы
- Автоматизация управления требованиями

### Основные моменты изменений:

- Причины изменений требований
- Условия возможности изменений
- Политика управления изменениями 
- Анализ влияния изменения 
- Принятие/непринятие изменений

### Причины изменения требований

- Заказчик
  -  Не понравилось после просмотра 
  - Передумал 
  - Забыл 
- Рынок 
  - Такой продукт уже не продать 
  - Нужно выйти на рынок прямо сейчас, иначе этот продукт не продать 
- Разработка 
  - Неточное определение границ проекта 
  - Требования плохо определены 
  - Требования не были поняты или были поняты неправильно 
  - Сработали архитектурные риски

### Условия возможности изменения требований

- **Водопадные стратегии** - практически не возможно
- **Инкрементные стратегии** – возможно с некоторыми ограничениями (на определенных этапах)
- **Эволюционные стратегии** - возможно (специализированы на проектах с изменениями требований)

### Политика управления изменениями

- Должен быть принят **процесс контроля за изменениями**
- Все изменения должны **следовать процессу** или **не рассматриваться** 
- Для неутвержденных требований не выполняется никаких действий, кроме исследования осуществимости 
- Все запросы на изменение должны быть одобрены советом по управлению изменениями 
- Содержание запроса на изменение должно быть доступно всем заинтересованным лицам проекта 
- Начальный текст запроса должен быть неизменным 
- Анализ воздействия должен проводиться для каждого изменения 
- Каждое одобренное изменение (добавленное требование) должно прослеживаться до запроса на изменение 
- Обоснование каждого одобрения на изменение должно быть задокументировано

### Анализ влияния изменения

- Выявление последствий внесения изменения
- Определение всех артефактов (файлы, модели, документы, шаблоны, …), которые нуждаются в модификации, если изменение будет принято
- Определение задач, необходимых для реализации изменения 
- Оценка усилий для завершения этих задач 
- Оценка нахождения этих задач на критическом пути проекта 
- Оценка влияния на график работ 
- Оценка влияния на стоимость 
- Оценка приоритета изменения, учитывая 
  - Достоинства 
  - Недостатки 
  - Затраты 
  - Риски

### Решения на запрос

- Отказ
- Принятие
  - С изменением сроков работ 
    - Формирование нового графика работ 
  - Без изменения сроков работ 
    - Откладывание низкоприоритетных требований 
    - Привлечение дополнительных сотрудников 
    - Организация краткосрочной сверхурочной работы 
    - Пожертвование качеством

# 19. Управление версиями требований. Отслеживание требований.

### Управление версиями требований

- Требования могут устаревать 
- Требования могут быть противоречивыми 
  - поддержка нескольких версий проекта одновременно (long-time, latest, beta)
- Контроль версий документов 
  - С помощью любой системы контроля версий 
- Контроль версий требований 
  - Создание начальных версий требований 
  - Ведение истории изменений 
  - Авторизованный доступ к изменениям требований

### Состояния требований

- **Принято** - Требование было выставлено авторизованным источником;
- **Одобрено** - Требование было проанализировано и одобрено для определенной версии;
- **Реализовано** - Код, реализующий требование, был написан;
- **Проверено** - Корректная функциональность данного требования была подтверждена версией продукта; Требование может быть прослежено до варианта тестирования;
- **Удалено** - Ранее одобренное требование было исключено из базисного списка; Причина удаления – задокументирована;
- **Отклонено** - Предложенное требование – отклонено; Причина отклонения – задокументирована.

### Отслеживание состояний требований

- Показатель прогресса проекта 
- Используется при анализе изменений 
- Обосновывает некоторые решения, принятые во время разработки 
- Обычно измеряется в процентах завершенности работ (грубая оценка)
  - Часто может вводить в заблуждение

# 20. Прослеживание требований.

**Цели:** 

- Получить подтверждение, что цели были реализованы 
- Убедиться, что требования были протестированы 
- Иметь трассы всех требований от заказчика до тестовых случаев

### Типы связей:

- Потребности заказчика с разработанными требованиями 
- Требования с исходными потребностями заказчика 
- Требования с определенными элементами продукта 
- Определенные элементы продукта с соответствующими требованиями

![20.1](img/20.1.png)

![20.2](img/20.2.png)

![20.3](img/20.3.png)

# 21. Ресурсы в программных проектах. Управление ресурсами 

**Ресурс** – объект проекта, подлежащий управлению и планированию, без которого невозможно выполнить какую-либо задачу программной инженерии. 

## Виды ресурсов: 

- Сотрудники 

  - Разделение на роли: Заказчик (customer), Менеджер проекта (project manager), Руководитель команды (team leader, team lead), Разработчик (developer), Тестер (tester, QA) и т.д.
    - Роль - конкретное амплуа сотрудника в конкретном проекте в определенное время. В программных проектах обычно оперируют ролями, а не сотрудниками

- Рабочее время 

  - Свойство сотрудника занимать какую-то роль определенное вермя в поректе. Является атрибутом связи «сотрудник-роль».

  Должно учитываться при формировании команды: 

  - Нестандартное время работы 
  - Выходные 
  - Сверхурочные 
  - Отпуска 
  - И т.д.

  Отдельно стоит учитывать праздники (особенно при транснациональном проекте), т.к. это может влиять на стоимость проекта, время старта/финиша проекта и т.д.

  В общем случае является внешним ограничением при решении задачи планирования

- Оборудование 

  Варианты:

  - Специализированное оборудование для разработки проекта 
  - Специализированное оборудование для исполнения проекта 
  - Специализированное оборудование для тестирования проекта 

- Машинное время

  - Если оборудование является узким ресурсом, то это то время, которое мы можем пользоваться в целях создания/тестирования проекта является ресурсом, которым необходимо управлять

- ПО (ОС, среда разработки, специализированный софт и т. д.)

  Варианты:

  - ПО для разработки проекта 
  - ПО для исполнения проекта 
  - ПО для тестирования проекта 

Оборудование/машинное время или ПО могут стать узким местом, если одновременно требуется разработчикам для отладки, тестироваям для отладки и заказчику.
Этих элементов оборудования может быть недостаточное число, в результате чего возникают проблемы.

Оборудование, машинное время и ПО в общем случае являются внешними ограничением при решении задачи планирования.

# 22. Роли участников в программных проектах

Роль - конкретное амплуа сотрудника в конкретном проекте в определенное время. 
В программных проектах обычно оперируют ролями, а не сотрудниками.

Состав, назначение и функциональные обязанности ролей зависят от конкретного процесса разработки в компании. 
В принципе возможно совмещение разных ролей в разных проектах.

## Роли в процессе разработки программных проектов:

- Основные:
  - __заказчик__ (customer)
  - __планировщик ресурсов__ (planner)
  - __менеджер проекта__ (project manager)
  - __архитектор__ (architect)
  - __руководитель команды__ (team leader, team lead)
  - __разработчик__ (developer)
  - __тестер__ (tester, QA)
  - __разработчик документации__ (technical writer)
  - __пользователь__ (user)
  - __инженер группы поддержки__ (support engineer)

- Дополнительные:
  - __эксперт предметной области__
  - __специалист по пользовательскому интерфейсу и эргономике__
  - __ответственный за выпуск релизов__
  - и т.д.

## Конкретнее о некоторых ролях:

### Заказчик:

- Инициирует разработку
- Участвует в сборе требований
- Участвуете в разработке спецификаций требований
- Принимает результаты разработки

### Планировщик ресурсов:

- Член руководства организации 
- Выдвигает и координирует требования к проектам в организации
- Развивает и направляет план выполнения проекта с точки зрения организации
- Обеспечивает финансирование проекта

### Менеджер проекта:

- Внешние функции:
  - взаимодействия с _заказчиком_ и _планировщиком ресурсов_
- Внутренние функции:
  - Распределяет задачи среди членов команды
  - Организует выполнение проекта
  - Контролирует процесс разработки

### Архитектор:

- Проектирует архитектуру системы
- Разрабатывает основные проектные решения
- Определяет общий план развития проекта
- Определяет инфраструктуру разработки

### Руководитель команды:

- Является "главным разработчиком"
- Осуществляет техническое руководство командой
- Разрешает технические вопросы

### Разработчик:

- Реализует проектируемые компоненты
- Создает классы и методы
- Осуществляет кодирование
- Разрабатывает модульные тесты
- Выполняет автономное тестирование
- Внутри команды может иметь специализацию

### Тестировщик:

- Проверяет качество программного обеспечения (функциональность, надежность, эффективность и т.д.). 
  Составляет тесты для каждой фазы проектирования продукта.
- Исполняет созданные тесты
- Выполняет функциональное тестирование 
- Выполняет интеграционное, системное тестирование

### Разработчик документации: 

- Разработка программной документации
- Разработка эксплуатационной документ
- Ведение информационной поддержки процесса разработки

### Пользователь:

- Не является заказчиком проекта
- Может являться, а может и не являться сотрудником проекта
- Является главным потребителем проекта
- Обычно существуют группы пользователей проекта

### Эксперт предметной области: 

- Обеспечивает информационную поддержку в предметной области проекта
- Может быть несколько экспертов, если проект большой

### Специалист по пользовательскому интерфейсу и эргономике:

- Проектирует пользовательские интерфейсы
- Взаимодействует с заказчиком
- Анализирует и оценивает комплексные характеристики интерфейса:
  - Удобство
  - Эргономичность
  - Лаконичность 
  - Дружественность
  - Локализуемость
  - ...

### Ответственный за выпуск релиза:

- Определяет и реализует политику выпуска релизов
- Формирует и проверяет требования к конкретному релизу:
  - Необходимая функциональность
  - Состав релиза
- Определяет дату выхода релиза
- Контролирует процесс выхода релиза

### Библиотекарь:

- Ведет библиотеку проекта
- Контролирует соответствие выпускаемого продукта принятым стандартам

## Совмещение ролей

![Combining_roles](img/combining_roles.png)

# 23. Взаимодействие между ролями в программных проектах

## Связи для планировщика ресурсов

![conn_for_planner](img/conn_for_planner.png)

## Связи для менеджера проекта

![conn_for_PM](img/conn_for_PM.png)

## Связи для архитектора

![conn_for_architect](img/conn_for_architect.png)

## Связи для руководителя команды

![conn_for_TL](img/conn_for_TL.png)

## Связи для разработчика

![conn_for_developer](img/conn_for_developer.png)

## Связи для тестировщика

![conn_for_tester](img/conn_for_tester.png)

## Связи для разработчика документации

![conn_for_TW](img/conn_for_TW.png)

## Связи для пользователя

![conn_for_user](img/conn_for_user.png)

## Связи для заказчика

![conn_for_writer](img/conn_for_writer.png)

# 24. Проектные активности программных проектов

- Программный проект - самостоятельно управляемый элемент разработки
- Нормальный результат программного проекта - программный продукт

Для того чтобы пройти все эти стадии нам необходимо управлять не только ресурсами, но и теми сущностями, что у нас есть внутри программного проекта.

Сущностей довольно-таки много и в общем случае разработчик, работая над проектом, обычно занимается двумя основными активностями:

1. Выполнение задач из ТЗ (подчиненных проектов, работ, реализация изменений)
2. Исправление дефектов (bug fixing)

Принципиальное отличие первого пункта от второго - первое, то что входит в проектный план, это запланированные активности, которыми разработчик должен заниматься для удовлетворения требований ТЗ, в то время как исправление дефектов - это непрогнозируемая активность, которой разработчик начинает заниматься в случае, если тестировщик обнаружил ошибки в программном коде, в функционировании программной системы.  

Сколько будет найдено ошибок, когда они будут найдены, насколько сложны эти ошибки, спрогнозировать невозможно, поэтому кроме прогнозируемых активностей разработчик занимается непрогнозируемыми активностями.

# 25. Временные сущности программных проектов

Временные сущности проектов:   

- Этапы (**stage**)
- Вехи (**milestone**)

## Этап программного проекта

Этап проекта – множество задач проекта, подчиненных достижению какой-либо локальной цели.   
Обычно этап – элемент проекта, видимый Заказчику. Заказчик может контролировать выполнение этапа.   
К этапам обычно привязано финансирование проекта.   
Завершение этапа может сопровождаться:

- Созданием макета
- Выпуском версии продукта
- Реализации компонента продукта
- ...

По окончании этапа можно принимать кардинальные (важные) решения:

- Продолжение проекта или его завершение (прекращение)
- Перепланирование проекта
- Изменение финансирования
- ...

Обычно в договоре между Заказчиком и Исполнителем указано, после какого этапа какие решения можно принимать.

## Вехи проекта

Веха (**milestone**) – законченная часть какого-либо этапа работы.  
Веха используется, чтобы примерно понимать как быстро происходит разработка проекта.   
Вехи стараются делать равномерными и небольшими по времени (например, каждую неделю), а задачи разбивать на подзадачи, чтоб они полностью входили в этот интервал.   
Достижение вехи можно наблюдать и контролировать.   
Вехи – те контрольные точки, по которым можно грубо оценить успешность всего проекта.   
В зависимости от способа организации проекта веха может быть:

- Видимой только Менеджеру проекта (внутренний ориентир)
- Видимой Менеджеру и Заказчику (так же, как и этап)

## Выполнение проекта

Процесс выполнения программного проекта – взаимосвязанное существование во времени:

- Проектных активностей
- Ресурсов
- Временных сущностей

# 26. Визуализация плана

Визуализация – основной способ планирования, контроля и наблюдения за программным проектом.

Визуализировать план можно только для **классических** методологий (у **Agile** методологий нет исходного плана).
Существует два основных подхода:

- Диаграммы Ганта
- Диаграммы PERT

## Диаграммы Ганта

Придуманы Генри Гантом в 1910 году и использовались во время проектирования и постройки кораблей.   
С конца 20-го века Диаграммы Ганта стали использоваться в программной инженерии как один из стандартных способов визуализации плана проекта.

![Gant](img/Gant.png)

Легенда:

| Что?                              | Зачем?                                                       |
| --------------------------------- | ------------------------------------------------------------ |
| Список задач (слева)              | Задачи, которые необходимо выполнить                         |
| Временной интервал (сверху)       | Время, за которое эти задачи необходимо выполнить (дни, недели, месяцы и т. д.) |
| Синие прямоугольники              | Задачи, примерно распределённые по времени в соответствии с планом проекта |
| Надписи (у синих прямоугольников) | Ресурсы, требующиеся для выполнения этой задачи (например, конкретный соотрудник) |
| Стрелочки                         | Информационная зависимость между задачами (последовательное выполнение) |
| Чёрные жирные линии               | Контейнеры (агрегаторы), соответствующие группе задач - этап проекта |

Достоинства:

- **Наглядность**: ширина прямоугольников строго пропорциональна времени выполнения этой задачи
- **Привязка к временной оси**
- Вертикальная черта - срез по задачам
- Иногда прямоугольники показывают в виде **progressBar**'ов, если есть связь с **BugTracking**'ом (все средства управления проектом автоматизированы и интегрированы между собой) 

Недостатки:

- Не настолько информационно мощный, как Диаграммы PERT

Программые продукты:

- GanttProject
- OpenProj
- EdrawSoft
- MS Project
- MS Visio
- MS Excel
- другие...

Многие продукты позволяют рисовать Диаграммы Ганта в автоматическом режиме.

## Диаграммы PERT

Program Evaluation and Review Technique, 1958 год.   
Другие названия: сетевой график, сетевой план-график.

Отличие от Диаграммы Ганта в большей формальности.

![PERT](img/PERT.png)

Легенда:   

| Что?                                        | Зачем?                                                       |
| ------------------------------------------- | ------------------------------------------------------------ |
| Узлы графа                                  | Вехи проекта (**milestones**), место соединения и распараллеливания задач |
| Цифры в узлах                               | Краткое обозначение узла                                     |
| Рёбра (дуги) графа                          | Задачи, которые необходимо выполнить                         |
| Обозначение дуг (Заглавные латинские буквы) | Краткое обозначение задачи                                   |
| Вес ребра                                   | Время, за которое эту задачу необходимо выполнить (дни, недели, месяцы и т. д.) |

Применяется для анализа критического пути проекта или запасов по времени, при изменении проекта.

Достоинства:

- Формальный граф со связями, по которому легко найти критический путь проекта (цепочка задач, которая определяет общее время выполнения проекта)
- Задачи, которые не попали в критический путь, могут понадобиться Менеджеру проекта, например, при перепланировании проекта
- Можно решать задачи на графах (поиск самого короткого пути, поиск самого длинного пути и т. д.)

Недостатки:

- Нет оси времени, что уменьшает наглядность диаграммы
- Нет общего списка задач (задачи разбросаны по всей плоскости)

Выход - нечто среднее между Диаграммой Ганта и Диаграммой PERT:

- Вводят ось времени
- Проекция задачи на ось времени должна быть пропорциональна времени выполнения этой задачи

Инструменты создания PERT-диаграмм:

- Edrawsoft
- Creately
- SmartDraw
- MS Project
- MS Visio
- другие...

Инструменты позволяют интегрировать Диаграммы PERT, например, с системой **BugTracking**'а или с системой управления требованиями.

# 27. Наблюдение за программным проектом

Наблюдение за проектом – процесс контроля хода выполнения проекта на основе анализа артефактов проекта.

Можно наблюдать за:   

1. Программными активностями:

    - Задачи   

    - Исправляемые дефекты   

    - Фиксации изменений (коммитов)

2. Ресурсами:

    - Сотрудники   

    - Оборудование   

    - ...


3. Соблюдением временных сущностей:

    - Этапы   

    - Вехи   

    - Критический путь проекта

Из этого возникают следующие виды срезов: 

- По задачам
- По сотрудникам
- По вехам
- По дефектам
- По фиксации изменений (коммитов) в СКВ (Система контроля версий)
- По соблюдению критического пути проекта
- ...

## Срез по задачам 

- Сотрудники, занятые решением задачи (ресурсы, которые необходимы для решения этой задачи)
- Соответствие задач – графикам (Диаграммы Ганта и PERT)
- Процент завершенности по задачам проекта
- Общее количество дефектов у задачи
- Количество незакрытых дефектов у задачи
- ...

Большое количество дефектов у задачи может показывать хорошую работу тестировщиков, или разработчики пишут мало **unit**-тестов и не занимаются отладкой своего кода.    

## Срез по сотрудникам

- Текущие задачи сотрудника (больше 3-х - плохой признак)
- Отставание сотрудника от графика (плохо работает, или слишком много задач)
- Общее количество дефектов, относящихся к сотруднику
- Количество незакрытых дефектов, относящихся к сотруднику
- ...

## Срез по дефектам

- Количество дефектов для каждой задачи (распределение дефектов между задачами должно быть примерно равномерным)
- Количество незакрытых дефектов для каждой задачи
- История изменения дефектов
- Среднее время исправления дефекта
- Среднее количество дефектов (открытых и закрытых) у сотрудников
- Распределение дефектов по сотрудникам
- ...

По этому срезу можно анализировать неравномерность загрузки проекта.

## Срез по фиксациям изменений (коммитов) в СКВ

- Среднее число коммитов на сотрудника за единицу времени
- Равномерность коммитов у сотрудников
- ...

## Срез по критическому пути проекта

- Сотрудники, выполняющие задачи в критическом пути (ключевые сотрудники)
- Задачи в критическом пути
- Временные запасы в критическом пути (экономия времени на выполненных задачах).
  Это время может быть потрачено на дополнительное тестирование проекта.

# 28. Управление риском в программных проектах: идентификация, анализ, ранжирование

Риск - возможность неудачи, неудовлетворительного результата
Риски в программных проектах:

- Бюджет (Превышение бюджета)
- Сроки (Превышение сроков)
- Функциональность (Низкая надежность , Некорректное функционирование , Низкое качество)

Формула для расчета риска:
R = P(UR)*L(UR)

 - R - показатель риска
 - P - вероятность неуспешного результата 
 - L - потери от неуспешного результата

Управление риском:

 - Идентификация риска
 - Анализ риска
 - Ранжирование риска 
 - Планирование управления риском 
 - Разрешение риска
 - Наблюдение за риском

### Идентификация риска:

Обнаружение всех рисков которые присутствуют в проекте
Риски можно разделить на 3 категории:

 - Проектные риски
 - Технические риски
 - Коммерческие риски

Проектные риски:

 - Это риски связанные с самим выполнение проекта (Выбор бюджета , план , человеческие ресурсы проекта)
 - Формирование требований к продукту
 - Проблемы с кадрами (Кто то может заболеть , уволится)
 - Сложность , размер , структура программного проекта
 - Методика взаимодействия с заказчиком

Технические риски:

 - Трудности этапов проектирования , реализации , тестирования , сопровождения
 - Неполнота или неточность спецификаций
 - Сомнительность принятых технических решений

Коммерческие риски:

 - Продукт не требуется на рынке
 - Продукт слишком устарел
 - Продукт слишком новаторский
 - Возможность прекращения финансирования

### Анализ риска:

Оценка вероятности возникновения каждого типа рисков и величины потерь

 - Вероятности определяются на основе экспертных оценок и статистики
 - Все риски заносятся в таблицу:

![logo](https://i.ibb.co/r47J0bs/image.png)

### Ранжирование риска:

- Сортировка рисков, пропорционально влиянию
- 20% элементов риска – обычно составляют 80% суммарного проектного риска


# 29. Управление риском в программных проектах: планирование, разрешение, наблюдение.

### Планирование управления рисками.

Цель – сформировать набор функций управления каждым элементом риска

Выбираются эталонные уровни риска – такие которые могут быть причиной прекращения проекта:

 - Превышение стоимости
 - Срыв планирования
 - Деградация технических показателей (характеристик)

Как формируются эти уровни риска? Они формируются отдельно по всем показателям: 
по стоимости, по времени и по качеству, и формируются они качественно. 
Например, делается следующим образом: уровни влияния на стоимость - вводятся пять качественных уровней, в которых мы определяем степень влияния риска на стоимость проекта.

![logo](https://i.ibb.co/d4XvgcS/image.png)

Уровни влияния на сроки:

![logo](https://i.ibb.co/tDyvDDs/image.png)

Уровни влияния на технические показатели:

![logo](https://i.ibb.co/fH7qmjD/image.png)

Уровни вероятности:

![logo](https://i.ibb.co/P9x2J6R/image.png)

Дальше на основании всего это строим матрицу риска

![logo](https://i.ibb.co/HC4Mz7P/image.png)

В данном случае пример: это такая двумерная табличка - по вертикали указывается вероятность, по горизонтали последствия, квадратики 1, 2, 3, 4, 5 - это качественные уровни. Дальше это все красится: зеленый цвет - все в порядке,
желтый цвет - в общем ситуация близкая к опасной, и красный цвет - мы близки к провалу. 

Почему именно такая раскраски? почему по диагонали?

R = P * L - гипербола - показывает линии равного уровня влияния (в каждой точки гиперболы произведение p*c одинаковое - одинаковый уровень риска)

Условно говоря то, что выше верхней прямой, мы раскрашиваем красным. То, что между желтым и зеленым, то есть мы берем два уровня - один уровень критический, при котором все ломается и совсем все плохо, и второй соответственно предупредительный, когда все не очень плохо. А то, что получились такие квадратики это аппроксимация гиперболы, то есть это не аппроксимация прямой, а гиперболы, т.е. если у вас будет не пять уровней, а например десять, то ситуация будет гораздо более точная. 

![logo](https://i.ibb.co/HxmyzL9/image.png)

Дальше:

 - Строятся зависимости между элементом риска и эталонными уровнями риска
 - Строится план управления каждым элементом риска
 - План интегрируется в общий план проекта

### Разрешение риска

Это плановое применение действий по уменьшению риска. 

### Наблюдение

 - Цикличность
 - Корректировка

### Методика управления рисками №2

![logo](https://i.ibb.co/ZcfYWpr/image.png)

### Стандарты управления рисками

![logo](https://i.ibb.co/gSdkqF6/image.png)

# 30. Понятие дефекта программного обеспечения. Характеристики дефектов

### Понятие дефекта программного обеспечения

**Дефект (ошибка, проблема, баг)** - обнаруженная в процессе разработки, тестирования или эксплуатации ошибка в 
разрабатываемом приложении. 
Это может быть отклонением от спецификаций программного обеспечения, и дефекты
требуют исправления. Исправление дефекта является самостоятельной проектной активностью.

### Характеристики дефектов

Характеристиками дефекта являются:

- **Идентификатор дефекта** - это ID дефекта, который должен
  - Быть уникальным среди **всех** проектов предприятия (все проекты делят общее пространство ID дефектов)
  - Должен существовать простой механизм поиска дефекта по его ID
  - Должен быть постоянным в процессе жизненного цикла проекта, так как
    - На дефект могут быть ссылки в документации
    - Могут быть ссылки от внешних заинтересованных сторон
    - Могут быть ссылки по зависимостям
- **Состояние дефекта**
  - Показывает этап жизненного цикла дефекта. Возможные состояния:
    - Новый
    - Взятый на исправление
    - Исправленный
    - Закрытый (исправленный и проверенный)
    - Незакрытый (исправленный, но проваливший проверку)
    - Отклоненный
    - Дубликат
    - Заново открытый
    - Приостановленный
    - Требующий пояснения
    - Не проявляющийся
    - (и т.п. в зависимости от проекта, политики и другого)
- **Описание дефекта**
  - Текстовое описание, дающее исчерпывающее представление о проявлении дефекта. 
    По этому описанию должно быть возможно повторить условия, в которых проявляется дефект. Например:
    - Шаги воспроизведения
    - Фактический результат
    - Ожидаемый результат
  - Может содержать ссылки на требования и т.п.
- **Автор**
  - Автор – лицо (сотрудник), обнаружившее дефект
  - Автором может быть
    - Тестер
    - Заказчик
    - Пользователь
    - Разработчик
    - любой, имеющий права фиксировать дефекты для данного проекта
- **Время обнаружения**
- **Контекст**
  - Дефект обычно связан с каким-либо проектом или задачей 
    (например, дефект относится к такому-то проекту и появился в результате выполнения такой-то user story)
  - Должна указываться версия (версии) проекта или задачи. 
    В процессе жизненного цикла проект и версия могут уточняться
- **Срочность**
  - Приоритет дефекта
  - Показывает относительную срочность исправления дефекта с точки зрения нашедшего его
  - Обычно выражается в относительных единицах: `низкая`, `средняя`, `высокая`, `срочная`
- **Серьезность (важность)**
  - Показывает степень влияния проявления дефекта на проект
  - Косметический дефект
    - Рабочий дефект
    - Дефект, вызывающий зависание приложения
    - Дефект, вызывающий аварию приложения
    - Дефект, вызывающий потерю или нарушение целостности данных
    - И другое
- **Категория**
  - Описывает тип найденного дефекта
  - Возможные категории:
    - Функциональный дефект
    - Дефект документации
    - Дефект требований
- **Ответственный за исправление**
  - Ответственный за исправление дефекта – лицо, в задачу которого входит устранение дефекта
  - В зависимости от политики управления ответственный за исправление дефекта
    - Может назначаться автоматически (например, менеджер проекта)
    - Может явно назначаться вручную
- **Ответственный за проверку**
  - Ответственный за проверку дефекта – лицо, в задачу которого входит проверка успешности устранения дефекта
    (необязательно автор дефекта)
  - В зависимости от политики управления ответственный за проверку дефекта
    - Может назначаться автоматически (например, тестер проекта)
    - Может назначаться вручную
- **Версия, в которой дефект исправлен**
- **Зависимости** 
  - Показывает зависимости исправления данного дефекта от исправления других дефектов
  - Зависимости представляются в виде списка идентификаторов дефектов, от которых зависит данный дефект
- **Временные параметры устранения дефекта**
  - Желаемое время, когда требуется устранить дефект
  - Желаемая версия проекта, к которой требуется устранить дефект
- **Дополнительные параметры:**
  - **Резолюция**
    - Необязательная текстовая реакция ответственного за исправление
    - Может сопровождать переход дефекта из одного состояния в другое 
      (например, из `взятый на исправление` в `исправленный`)
    - По сути показывает, что работа над исправлением завершена 
      (не обязательно `fixed`, может быть и `won't do`, `cannot reproduce`)
  - **Способы обхода**
    - Необязательная текстовая реакция ответственного за исправление
    - Показывает, как можно использовать систему до окончательного исправления дефекта 
      (аля как можно накостылить работу с программой так, чтобы работало и с багом)
    - Может сопровождать переход дефекта из одного состояния в другое
  - **URL**
  - **Attachments**
    - Файл с логами, скриншот или любой другой документ, 
      который может помочь прояснить причину ошибки или указать на способ решения проблемы

# 31. Жизненный цикл дефекта.

В общем виде жизненный цикл основан на смене состояний дефекта.

Как было описано ранее, дефекты могут иметь следующие состояния, 
но этот список может быть произвольно расширен или сужен в зависимости от политики компании:

- Новый
- Взятый на исправление
- Исправленный
- Закрытый (исправленный и проверенный)
- Незакрытый (исправленный, но проваливший проверку)
- Отклоненный
- Дубликат
- Заново открытый
- Приостановленный
- Требующий пояснения
- Не проявляющийся
- (и т.п. в зависимости от проекта, политики, фантазии и другого)

В общем случае каждая СУД (система управления дефектами) имеет свой стандартный жизненный цикл дефекта, 
но они очень схожи, поэтому можно рассмотреть жизненный цикл на примере JIRA (смотри на белом фоне, там лучше видно)

![31-jira-bug-lifecycle.png](img/31-jira-bug-lifecycle.png)

Стандартный жизненный цикл состояний для дефекта выглядит примерно как

- Новый
- Взятый на исправление
- Исправленный
- Закрытый (исправленный и проверенный)

Но в зависимости от ситуации может оказаться так, что жизненный цикл состояний изменится. 
Например, если разработчик ошибся при исправлении дефекта то путь может выглядить так:

- Новый
- Взятый на исправление
- Исправленный
- Заново открытый
- Взятый на исправление
- Исправленный
- Закрытый (исправленный и проверенный)

---

При этом в течение жизненного цикла дефекта его характеристики могут изменяться, например:

- Переход из одного состояния в другое состояние (как раз описано выше)
- Изменение ответственного за исправление
- Изменение ответственного за проверку
- РЕДКО: изменение автора
- Изменение контекста
- РЕДКО: Изменение серьезности
- Изменение срочности
- РЕДКО: Изменение категории
- Изменение содержания
- Изменение резолюции
- Изменение способа обхода

Права на изменение той или иной характеристики зависят от разных факторов, среди них могут быть:

- Состояния дефекта (например, нельзя перевести дефект из `Новый` сразу в `Заново открытый`)
- Роли сотрудника (например, закрыть дефект может только QA)
- Политики компании

# 32. Системы управления дефектами.

Другие названия:

- Системы отслеживания ошибок
- Системы управления изменениями и дефектами
- Трассировка изменений
- Трассировка ошибок
- Управление инцидентами
- Управление рекламациями
- Bug tracking system
- Issue tracking system
- и т.п.

Для управления дефектами (их характеристиками и жизненным циклом, правами доступа и т.п.) существует специализированное
программное обеспечение - **системы управления дефектами**
Данные системы контролируют жизненный цикл дефекта и предоставляют дополнительные возможности, что упрощают работу
команды разработки ПО.

Примеры:

- Коммерческие
  - IBM Rational ClearQuest
  - Microfocus StarTeam
  - Atlassian JIRA
  - JetBrains YouTrack
  - И другие
- Свободно распространяемые
  - Mozilla Bugzilla
  - Trac
  - Redmine
  - MantisBT
  - TUTOS
  - Интегрированные в серверы хостинга проектов (BitBucket, GitHub и т.п.)
  - И другие

---

Типичный жизненный цикл дефекта в различный системах управления дефектами различаются, но обычно они имеют 5 стандартных стадий:

- Новый (открыт)
- Взят на исправление
- Исправлен
- Закрыт (исправлен и проверен)
- Переоткрыт (например в случае, если такой же дефект воспроизвелся снова, по сути эта стадия совпадает с состоянием `Открыт`)

**ПОСЛЕ КАРТИНОЧЕК ЕЩЕ ИНФА ЕСТЬ, НЕ ЗАБУДЬ**

Типичные жизненные циклы в некоторых СУД:

- `Mozilla Bugzilla`![32-mozilla-bugzilla.png](img/32-mozilla-bugzilla.png)
- `Trac` ![32-trac.png](img/32-trac.png)
- `Redmine` ![32-redmine.png](img/32-redmine.png)
- `Jira` ![32-jira.png](img/32-jira.png)
- `Jetbrains YouTrack` ![jetbrains-youtrack.png](img/32-jetbrains-youtrack.png)

---

Кроме того СУД позволяют отправлять пользователям нотификации при различных обновлениях:

- Появление нового дефекта
- Изменение состояния существующего дефекта
- Изменение характеристик существующего дефекта

Нотификации можно отправлять различными способами:

- Интерактивными
  - SMS
  - Системы обмена мгновенными сообщениями
- Не интерактивными
  - E-mail
  - Через клиент СУД

Дополнительно можно гибко настраивать нотификации, например:

- По отношению к роли
- По отношению к свойствам дефекта
- По отношению к состоянию дефекта
- И другое

---

Ввиду наличия дополнительных возможностей СУД и некоторой схожести характеристик/жизненного цилка задач и дефектов, 
СУД используют не только для отслеживания дефектов, но и для управления задачами. 
Однако следует помнить, что задачи все же имеют свой жизненный цикл

Для визуалиции работы и прогресса используются так называемые `agile-доски`, `scrub-доски`, `kanban-доски`, 
которые представляют из себя таблицу с карточками

- Столбцы таблицы – важные состояния работ (задач)
- Наполнение столбца – задачи, находящиеся в данном состоянии 
- Место задачи в столбце – приоритет

Данные доски позволяют наглядно визуализировать все типы работ по проекту или этапу проекта и менять приоритеты работ

![32-agile-boards.png](img/32-agile-boards.png)

Сервисы, предоставляющие это:

- Trello
- Jira
- JetBrains YouTrack
- И другие

# 33. Предпосылки для версионирования ПО. Ветвление.

## Предпосылки.

### Необходимость групповой работы.

Основные задачи: 

* Повышение надежности хранения артефактов.
* Общий доступ к артефактам.
* Сохранение истории модификации артефакта.
* Возможность возврата к предыдущим версиям.
* Пометка отдельных версий файла.
* Поддержание и развитие нескольких.
  параллельных историй артефакта.
* Поддержка нескольких конфигураций проекта.
* Сравнение версий.
* Объединение разрозненного кода.

### Необходимость общего доступа к артефактам.

* Одновременное редактирование одного
  артефакта разными пользователями.
* Потеря изменений, сделанных
  пользователем (затерты записью
  изменений другого пользователя).

** В параллельных системах для разрешения
используются семафоры, мьютексы, критические
секции и т.п.

### Необходимость сохранения истории модификации артефакта.

Нужно хранить:

* Версию.
* Автор изменения.
* Время изменения.
* Суть изменения.
* Причина изменения.
* И т.п.

### Необходимость пометки отдельных версий артефакта.

Хотим оставить тэги/нотации, на конкретные артефакты в истории, это может быть 
необходимо по следующим причинам:

* Качественная версия, т.е например исправили большое число ошибок и хотим зафиксировать ситуацию
* Версия обладает определёнными свойствами, например версия стала работать под сиситемой андроид, или
  появился раздел помощи и т.п.
* Версия, являющаяся частью релиза проекта определенной версии. Например альфа версия, бета 
  версия и т.п. Почему не самая последняя версия? - Необходимо уметь восстановиться в случае 
  если в последующих версиях была регрессия, и могли воспроизвести и исправить ошибки 
  определённой версии.

### Необходимость поддержки и развития нескольких историй артефакта.

Зачем нужно ветвить версии файла:

* Одновременное развитие нескольких версий проекта, например по причине изменения требований.
  Например необходимы следующие версии:
    * Поставляемые заказчику.
    * Разрабатываемые.
* Разработка новой функциональности, которая ведётся в отдельной ветке, чтобы в будущем слить 
  изменения, либо если эксперимент оказался неудачный, не навредить основной функциональности.

### Необходимость поддержки нескольких конфигураций проекта.

*  Наличие нескольких конфигураций проекта для:
   * разной аппаратуры.
   * разного системного програмного обеспечения.
   * разных комплектов поставки. Например распространяем продукт за деньги, но есть 
     бесплатная версия с ограниченным функционалом.
*  Разработка новой (экспериментальной) функциональности.

## Ветвление

* Ветвь (ветка, branch) – механизм, который служит для ветвления дерева ревизий файла.
* Имя ветви однозначно определяет группу ревизий (ветвь).
* Имя ветви используется для переключения между ветвями ревизий файла.

# 34. Системы контроля версий. Типы СКВ. Общие принципы организации. 

Другие названия системы контроля версий:

* Системы управления версиями (VCS - Version
  Control System).
* Системы контроля ревизий (RCS - Revision
  Control System).
* Системы управления исходным кодом (SCM –
  Source Code Management).

Системы контроля версий - это специализированные програмные инструменты , которые решают задачу
автоматизации групповой работы и управления версионированием проектов.
Изначально только для программных проектов.Но сейчас используются почти во всех областях, где есть 
атрефакты, сохраняемые в виде файлов операционной системы и над которыми можно работать. Например 
проекты по управлению созданием аппаратуры; написание документации, статей, книг и т.д. 
Везде где есть артефакты, файлы, которые могут версионироваться, отмечаться, удаляться, 
сравниваться и т.д.

## Общие принципы систем контроля версий

Системы контроля версий обеспечивают:

* Репозиторий (или несколько репозиториев) для хранения проектов и их артефактов. 
* Стандартизируют стандартные операции для групповой работы.Т.е вводят операции, необходимые 
  для групповой работы. Обычно таких операций 30-40 в каждой системе контроля версий.
* Предоставляют клиенты для разных операционных систем для выполнения операций. 
  Почти всегда есть текстовый(консольный) клиент для выполнения этих операций. 
  Консольный клиент необходим для автоматизации:
    * автоматизация сборки.
    * continuous integration.
    * continuous delivery.
    * и т.д.

Значит что эти операции выполняются не человеком, а роботом. Соответственно есть два подхода:

* сделать публичный API, которым будет пользоваться система автоматизации.
* использовать консольные приложения с публичным API - аргументы командной строки.

Почему используют командную строку, а не другой публичный API? Так как в случае использования API, 
пришлось бы сделать для всех возможных систем реализацию. В случае с командной строкой, при появлении
новой системы, просто изменяются конфигурационные файлы - названия команд и параметров, которые они принимаю, 
интерпретации вывода. Не придётся дописывать модуль интеграции или что то вроде этого.

Это является стандартом, когда интеграция с разными системами автоматизации может производиться 
через командную строку. В случае работы с API, такого же простого механизма нет.

## Типы систем контроля версий

Условно делят на два типа, у одного из которых есть два подтипа:

* централизованные файл-серверные системы контроля версий. Самые древние. 
  Организованы следующим образом:
    * имеется централизованное хранилище на сервере. 
    * Клиенты обращаются к хранилищу используя файл-серверный доступ. Файл-серверный доступ - 
      когда организуем взаимодействие двух приложений через разделяемые файлы, разделяемые файлы.
        Репозиторий, в котором хранятся проекты использыется как разделяемый ресурс, а клиенты через 
        средства операционной системы по управлению общими файлами доступаются к репозиторию.
        Например: MS Visual Source Safe. Единственные способ работы над файлом - его блокировка.
* Централизованные системы контроля версий. Организованы следующим образом:
  * имеется единое централизованное хранилище на сервере.
  * клиент-серверный доступ. Клиенты у пользователей, по специальному протоколу обращаются к серверу
    , где расположен репозиторий и операции осуществляются через серверное ПО и через клиентов.
    Например: CVS, Subversion.
* Распределённые системы контроля версий:
  * есть множество репозиториев. Есть центральный репозиторий + каждый компьютер является маленьким 
    репозиторием.
  * обмен информацией между отдельными репозиториями реализуется через специальные механизмы слияний
    (заплаток, патчей, change sets и т.п).
  * Используется в интернет-проектах, когда разработчики существенно удалены друг от друга.
    Например: mercurial, git, Bazaar и т.п.

Файл-серверные системы практически не встретить. Централизованные системы постепенно отдают 
пространство распределённым. 

Пример, когда нельзя работать в централизованной системе - система идеальна только при условии
, что у всех участников проекта есть интернет. Однако существует множество мест, где интернета нет, 
либо доступ периодами, либо слишком плохой. Ответ: когда необходми продолжать вести разработку 
в местах где нет интернета.

Минусы распределённой системы контроля версий:

* много сущностей - больше репозиториев.
* большое количество ежедневных операций, по сравнению с централизованной системой контроля версий.

Относительное преимущество централизованной системы контроля версий - всегда есть репозиторий, в котором есть 
последняя версия проекта. В распределённых системах у каждого рарзаботчика может быть разная версия проекта, в зависимости 
от того успел разработчик слить изменения или нет, сложно точно определить где последняя версия.

### Ревизия файла

Все файлы и артефакты, которые хранятся в системе контроля версий имеют уникальный идентификатор - 
ревизия файла. Примеры:

* CVS: 1.2.
* SVN: 238.
* Git, Mercurial: хэш SHA-1.

При любом изменении файла изменяется также и номер ревизии файла, по определённому правилу: 
например в системе SVN инкрементируется, в системе CVS инкрементируется последня значащая цифра
, когда требуется ревизия всего репозитория, то изменяется атрибут всего репозитория. 

У ревизий есть разные атрибуты: 

* идентификатор.
* автор, кто сделал данную ревизию.
* дата.
* текстовое описание, почему эта ревизия появилась
* внешние атрибуты:
  * тэги 
  * идентификаторы ветвей

Для централизованных систем контроля версий может быть несколько состояний в которых находится проект:

* локальная копия проекта, которая ещё не влита в репозиторий.
* локальная копия проекта, но под системой контроля версий, в таком случае добавляются скрытые файлы с 
  мета информацией.
* серверная копия репозитория

Для распределённых систем контроля версий существуют следующие состояния: 

* локальная копия проекта.
* локальная копия проекта, под контролем системы контроля версий.
* копия находящаяся в локальном репозитории.
* копия находящаяся в удалённом репозитории.

### Общие принципы храненм файлов в системах версионирования.

* Поддержка текстового и бинарного формата. Текстовый формат чаще всего нужен для 
  представления исходного кода артефактов. В текстовом формате реализуются слежующие функции:

    * хранение инкрементальных изменений. Хранится первая версия и "дельты" относительно первой версии.
    * возможность визуального сравнения ревизий

     Для бинарного формата следующие функции:

    * хранение полных версий артефакта. Например полная версия картинки, документации.
    * функции сравнения не предусмотрено.

    Хранение бинарных версий артефакта необходимо делать только в случае острой необходимости.

* Пометка версий в системе контроля версий, используются следующие способы пометки:

  * тэги
  * именованные виртуальные каталоги 

  Пометка тэгами - специализированными текстовыми метками, которые привязываются к какой либо 
  ревизии файла или репозитория. Для тэга важно быть неизменяемым для гарантии целостности.

  * одна ревизия может содержать несколько тэгов.
  * Выборку ревизии файла/файлов можно производить по тэгам.

  Именованные виртуальные каталоги:

  * Вместо тэга создается каталог.
  * В него помещаются виртуальные копии необходимых ревизий всех требуемых файлов
  * Работа с таким каталогом происходит стандартными способами
  * необходимо гарантировать неизменяемость файлов внутри каталога

# 35. Системы контроля версий. Типовые операции.

* Импорт проекта (import).
* Экспорт проекта (export).
* Получение проекта (checkout, clone, …).
* Обновление файла (update, fetch, ..).
* Фиксация изменений (commit).
* Сравнение изменений.
* Установка тэгов.
* Переход к другой ревизии (откат).
* Создание ветвей (fork,…).
* Переключение на ветвь.
* Слияние (merge).
* Разрешение конфликтов.
* Блокировка файлов.
* Выгрузка изменений (push).
* Запрос на изменение (pull request).

Импорт - первоначальное помещение локального проекта в репозиторий .

Экспорт - редкая операция, окончание разработки проекта, состоит из двух шагов:

* Извлечение проекта из системы контроля версий в локальный каталог.
* Удаление проекта из системы контроля версий.

Получение копии проекта: 

* Получение локального слепка проекта
* Получение осуществляется по одному из критериев:
  * Головная версия (HEAD, trunk, default, master, …).
  * Версия на определенную дату.
  * Версия с определенным тэгом.
  * Версия из определенной ветви.

Фиксация изменений:

* Посылка измененной версии файла в репозиторий
* Операция игнорируется, если ревизия на сервере изменилась

Обновление файлов:

* Копирование свежей версии из репозитория
* Слияние локальных изменений и серверных в локальном файле

Разрешение конфликтов
Конфликт - изменений одной и той же строки в двух версиях.

* Если при слиянии произошел конфликт – в текст попадают обе версии участков кода с пометками.
* Разрешение проводится только в локальной копии.
* В репозитории хранятся только утвержденные версии с разрешенным конфликтом.

Сравнение изменений:

* Действует только для текстовых файлов.
* Сравнивать можно любые две ревизии одного файла из любых ветвей проекта.

# 40. Документирование ПО. Виды программной документации.

Виды документации:

- **Проектная** - та документация, которая сопровождает программное обеспечение и содержит информацию о принятых технических решениях.
- **Программная** - описывает разработанное программное обеспечение и входящие в его состав артефакты.
- **Эксплуатационная** - описывает процесс использования программного продукта.
- **Рабочая** - не совсем верно ее выделять, представляет из себя различные реинкарнации в процессе разработки проекта проектной, программной и эксплуатационной документации (Ицыксон так сказал).

## Проектная документация.

Обычно создается в начале проекта и модифицируется по мере продвижения проекта.

Стандарты относятся ко всему проекту, а не к отдельным артефактам.

В состав проектной документации может входить документация, описывающая принятие проектные решения, архитектуру. ГОСТа на архитектуру нет, обычно входит в состав других документов.

![40-1](img/40-1.PNG)

## Программная документация

Программная документация посвящена описанию отдельных программных артефактов, создается в процессе разработки ПО, эволюционирует совместно с проектом.

Руководство программиста - для тех, кто будет использовать программу, не зная ее содержание (API)

![40-2](img/40-2.PNG)

## Эксплуатационная документация

Обычно создается по окончанию проекта, эволюционирует вместе со всеми дальнейшими изменениями проекта, предназначена для того, чтобы пользователь мог воспользоваться продуктом.

Руководство оператора - для тех, кто использует ПО

Руководство по техническому обслуживанию - для технических процедур (например, очистка баз данных, бэкапы и т.п.)

Руководство системного программиста - руководство по администрированию, настройке (для сисадминов).

![40-3](img/40-3.PNG)

## Рабочая документация

Рабочая документация - не тип документации, а ее состаяние. Отображает состояние проекта в текущий момент. 
Если процессы в компании поставлены правильно, то рабочая документация может стать программной или эксплуатационной (идеальное завершение жизненного цикла).

![40-4](img/40-4.PNG)

![40-5](img/40-5.PNG)

## Динамическая документация

**Динамическая документация** - документация в виде динамических артефактов, которые описывают,как устроена система.

КА протокола TCP - пример динамической документации. 

В некоторых случаях динамическая документация удобнее других типов.

![40-6](img/40-6.PNG)

![40-7](img/40-7.PNG)

# 41. Использование UML в документировании

![41-1](img/41-1.PNG)

Очень много времени и сил было потрачено на создание языка UML. 

**Язык UML** - это набор из около 2х десятков диаграмм, которые позволяют описывать разные аспекты ПО, в некоторых проектах (особенно для информационных систем) UML вполне пригоден.

UML не стал панацеей, хотя считалось, что им можно будет описывать все процессы разработки ПО. Оказалось, что он удобен далеко не везде.

![41-2](img/41-2.PNG)

**Диаграмма последовательностей** - показывают динамику диаграммы взаимодействия.

При разработке **диаграммы пакетов** показывает распределение функциональности по пакетам.

**Диаграммы состояний** - показывают динамику управления объектов и могут описывать реализацию элементов.

**Диаграмма компонентов** - показывает модульную структуру разработанной системы.

**Диаграмма развертывания** - показывает проецирование отдельных артефактов разработки на физическую архитектуру.

# 42. Генерация документации

Данный подход придуман давно Дональдом Кнутом. Оп предложил концепцию граммотного программирования и язык программирования WEB. WEB не имеет отношения к WWW это специализированный ЯП в котором было предложенно объединить внутри одного артефакта текст и документацию. И дальше использовть 2 компилятора. Один для получения кода, а второй для документации. Например, javadoc основана на концепции граммотного программирования. 

Основной подход сейчас - аннотирование текста программы с помощью структурированных комментариев которые позволяют описывать описывать программные модули, функции, классы, переменные, параметры функций и методов. Эти комментарии по сути своей язык с ключевыми словами которые не мешают при компиляции основным компилятором, но помогают при генерации документации а также помогают средам разработки  делать интерактивные подсказки, например, какие параметры есть у метода.

На основе этих аннотаций могут генерироваться:

- html – страницы
- Документ Word, rtf
- Документ PDF
- Документы XML

Этот подход может использоваться при подготовке программной документации. Есть два документа где эти комментарии нам помогут:

- Описание программы
- Руководство программиста. Этот докумет иногда при помощи подобных комментариев может быть создан полностью на 100%

Генераторы документации:

- Java - Javadoc

- C++ - Cppdoc

- Object Pascal - Pasdoc

- JavaScript - JSDoc

- Многоязыковые - Doxygen 

  Пример
  ![image](https://user-images.githubusercontent.com/43119772/149614143-c93f1361-a63f-4501-a064-428b79568768.png)

# 43.Промышленные технологии документирования

Такая документация может быть гигантского размера. В разных документах страницы могут частично повторяться, в зависимости от конфигурации под которую делается документ часть разделов документации повторяться, поэтому подход "копировать-вставить" не применим

Основные принципы

- Принцип единого источника - описание в одном месте а использование в документации в нескольких местах
- Использование структурированных текстовых форматов хранения документации
- Отделение семантики от форматирования - семантика храниться в виде структурированных текстовых документов в системе контроля версий. Форматирование меняется в зависимости от того, с какой целью создается документация
- Многократное использование контента
- Генерация многих видов документов из одной основы
  - Программная документация
  - Эксплуатационная документация
  - нтерактивные системы помощи
  - т.п.

- Поддержка разных форматов (HTML, PDF, ODF,
  DOCX и т.п.)

![image](https://user-images.githubusercontent.com/43119772/149614473-7c2b4d1b-47f3-41a8-a346-0c0883b6e800.png)

## LaTeX

- Набор макрорасширений для TeX
- Используется система тэгов для форматирования документов
- Поддерживается экспорт во все популярные форматы
- Последняя версия – LaTeХ 3ɛ

LaTeX - это текстовый формат, значит его можно хранить как текстовый артефакт и хранить  в системе котроля версий с возможностью сравнения версий, инкрементального хранения.

Пример:
![image](https://user-images.githubusercontent.com/43119772/149614595-50dbc20c-638e-4081-a581-8ebd49ff25b9.png)

## DITA

- Расшифровывается как Darwin Information Typing Architecture
- Разработана IBM
- Оформленна в виде стандарта OASIS: DITA 1.3, декабрь 2015 г.
- Dita - это набор XML–тегов и DTD-темы, которые описывают, как из описания формируются окончательные документы
- Охватывает весь цикл разработки, выпуска технической документации. Есть текстовые редакторы и конверторы текста.

## DocBook

- Стандарт OASIS: DocBook 5.1, ноябрь 2016 г.
- Набор XML-тэгов, структурирующих элементы документации
- XML-схема для валидирования коректности сохданного документа
- DocBook предоставляет более 400 тэгов
- Независимость содержания от представления. - Сам XML содержит только содержание а представление реализуется с помощью специального конвертера
- Принцип единого источника
- Легко конвертируется в любой формат
- Существуют DocBook-редакторы и фильтры для популярных текстовых процессоров

![image](https://user-images.githubusercontent.com/43119772/149614864-af433e65-9fae-443e-a604-50339c3fa01a.png)

Так как этот формат не так удобен как LaTeX, есть специальные редакторы для DocBook или наборы шаблонов Office, чтобы можно было DocBook документ создавать внутри Office и после форматировать и преобразовывать при помощи стандартных процессоров.